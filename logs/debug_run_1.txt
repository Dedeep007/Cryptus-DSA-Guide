Testing topic: String Algorithms (strings.json)
============================================================

≡ƒö╣ Problem: Roman to Integer
   Testing cpp       : --- WRAPPED CODE ---

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>
#include <cmath>
#include <queue>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>
#include <sstream>
using namespace std;



// Helper: print vector
template<typename T>
void printVec(const vector<T>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); i++) {
        if (i > 0) cout << ", ";
        cout << v[i];
    }
    cout << "]";
}

// Helper: print 2D vector
template<typename T>
void printVec2D(const vector<vector<T>>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); i++) {
        if (i > 0) cout << ", ";
        printVec(v[i]);
    }
    cout << "]";
}

int romanToInt(string s) {
    unordered_map<char, int> symbolValues = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000}
    };
    int result = symbolValues[s[0]];
    for (int i = 1; i < s.size(); i++) {
        if (symbolValues[s[i]] > symbolValues[s[i - 1]]) {
            result -= 2 * symbolValues[s[i - 1]];
            result += symbolValues[s[i]];
        } else {
            result += symbolValues[s[i]];
        }
    }
    return result;
}

int main() {
    string s = "III";
    auto result = romanToInt(s);
    cout << result << endl;
    return 0;
}
--------------------
--- WRAPPED CODE ---

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>
#include <cmath>
#include <queue>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>
#include <sstream>
using namespace std;



// Helper: print vector
template<typename T>
void printVec(const vector<T>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); i++) {
        if (i > 0) cout << ", ";
        cout << v[i];
    }
    cout << "]";
}

// Helper: print 2D vector
template<typename T>
void printVec2D(const vector<vector<T>>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); i++) {
        if (i > 0) cout << ", ";
        printVec(v[i]);
    }
    cout << "]";
}

int romanToInt(string s) {
    unordered_map<char, int> symbolValues = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000}
    };
    int result = symbolValues[s[0]];
    for (int i = 1; i < s.size(); i++) {
        if (symbolValues[s[i]] > symbolValues[s[i - 1]]) {
            result -= 2 * symbolValues[s[i - 1]];
            result += symbolValues[s[i]];
        } else {
            result += symbolValues[s[i]];
        }
    }
    return result;
}

int main() {
    string s = "LVIII";
    auto result = romanToInt(s);
    cout << result << endl;
    return 0;
}
--------------------
--- WRAPPED CODE ---

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>
#include <cmath>
#include <queue>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>
#include <sstream>
using namespace std;



// Helper: print vector
template<typename T>
void printVec(const vector<T>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); i++) {
        if (i > 0) cout << ", ";
        cout << v[i];
    }
    cout << "]";
}

// Helper: print 2D vector
template<typename T>
void printVec2D(const vector<vector<T>>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); i++) {
        if (i > 0) cout << ", ";
        printVec(v[i]);
    }
    cout << "]";
}

int romanToInt(string s) {
    unordered_map<char, int> symbolValues = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000}
    };
    int result = symbolValues[s[0]];
    for (int i = 1; i < s.size(); i++) {
        if (symbolValues[s[i]] > symbolValues[s[i - 1]]) {
            result -= 2 * symbolValues[s[i - 1]];
            result += symbolValues[s[i]];
        } else {
            result += symbolValues[s[i]];
        }
    }
    return result;
}

int main() {
    string s = "MCMXCIV";
    auto result = romanToInt(s);
    cout << result << endl;
    return 0;
}
--------------------
Γ£à PASS
   Testing c         : --- WRAPPED CODE ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>

int romanToInt(char* s) {
    int values[256] = {0};
    values['I'] = 1; values['V'] = 5; values['X'] = 10;
    values['L'] = 50; values['C'] = 100; values['D'] = 500; values['M'] = 1000;
    int result = values[s[0]];
    for (int i = 1; s[i] != '\0'; i++) {
        if (values[s[i]] > values[s[i - 1]]) {
            result -= 2 * values[s[i - 1]];
            result += values[s[i]];
        } else {
            result += values[s[i]];
        }
    }
    return result;
}

int main() {
    printf("%d\n", romanToInt(s));
    return 0;
}
--------------------
--- WRAPPED CODE ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>

int romanToInt(char* s) {
    int values[256] = {0};
    values['I'] = 1; values['V'] = 5; values['X'] = 10;
    values['L'] = 50; values['C'] = 100; values['D'] = 500; values['M'] = 1000;
    int result = values[s[0]];
    for (int i = 1; s[i] != '\0'; i++) {
        if (values[s[i]] > values[s[i - 1]]) {
            result -= 2 * values[s[i - 1]];
            result += values[s[i]];
        } else {
            result += values[s[i]];
        }
    }
    return result;
}

int main() {
    printf("%d\n", romanToInt(s));
    return 0;
}
--------------------
--- WRAPPED CODE ---
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>

int romanToInt(char* s) {
    int values[256] = {0};
    values['I'] = 1; values['V'] = 5; values['X'] = 10;
    values['L'] = 50; values['C'] = 100; values['D'] = 500; values['M'] = 1000;
    int result = values[s[0]];
    for (int i = 1; s[i] != '\0'; i++) {
        if (values[s[i]] > values[s[i - 1]]) {
            result -= 2 * values[s[i - 1]];
            result += values[s[i]];
        } else {
            result += values[s[i]];
        }
    }
    return result;
}

int main() {
    printf("%d\n", romanToInt(s));
    return 0;
}
--------------------
Γ¥î FAIL
      FULL RESULT: {"input":"\"III\"","expected":"3","actual":"file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory","passed":false,"error":"COMPILE_ERR: file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory\n\nSTDERR: file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory\n","isHidden":false}
      FULL RESULT: {"input":"\"LVIII\"","expected":"58","actual":"file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory","passed":false,"error":"COMPILE_ERR: file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory\n\nSTDERR: file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory\n","isHidden":false}
      FULL RESULT: {"input":"\"MCMXCIV\"","expected":"1994","actual":"file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory","passed":false,"error":"COMPILE_ERR: file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory\n\nSTDERR: file0.code.c: In function 'main':\nfile0.code.c:24:31: error: 's' undeclared (first use in this function)\n   24 |     printf(\"%d\\n\", romanToInt(s));\n      |                               ^\nfile0.code.c:24:31: note: each undeclared identifier is reported only once for each function it appears in\nchmod: cannot access 'a.out': No such file or directory\n","isHidden":false}
   Testing python    : --- WRAPPED CODE ---
import collections
from collections import deque, Counter, defaultdict
import heapq
import math
from typing import *

def romanToInt(s):
    symbolValues = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    }
    result = symbolValues[s[0]]
    for i in range(1, len(s)):
        if symbolValues[s[i]] > symbolValues[s[i - 1]]:
            result -= 2 * symbolValues[s[i - 1]]
            result += symbolValues[s[i]]
        else:
            result += symbolValues[s[i]]
    return result

s = "III"
result = romanToInt(s)
if isinstance(result, list):
    print('[' + ', '.join(str(x) for x in result) + ']')
elif isinstance(result, bool):
    print('true' if result else 'false')
else:
    print(result)

--------------------
--- WRAPPED CODE ---
import collections
from collections import deque, Counter, defaultdict
import heapq
import math
from typing import *

def romanToInt(s):
    symbolValues = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    }
    result = symbolValues[s[0]]
    for i in range(1, len(s)):
        if symbolValues[s[i]] > symbolValues[s[i - 1]]:
            result -= 2 * symbolValues[s[i - 1]]
            result += symbolValues[s[i]]
        else:
            result += symbolValues[s[i]]
    return result

s = "LVIII"
result = romanToInt(s)
if isinstance(result, list):
    print('[' + ', '.join(str(x) for x in result) + ']')
elif isinstance(result, bool):
    print('true' if result else 'false')
else:
    print(result)

--------------------
--- WRAPPED CODE ---
import collections
from collections import deque, Counter, defaultdict
import heapq
import math
from typing import *

def romanToInt(s):
    symbolValues = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    }
    result = symbolValues[s[0]]
    for i in range(1, len(s)):
        if symbolValues[s[i]] > symbolValues[s[i - 1]]:
            result -= 2 * symbolValues[s[i - 1]]
            result += symbolValues[s[i]]
        else:
            result += symbolValues[s[i]]
    return result

s = "MCMXCIV"
result = romanToInt(s)
if isinstance(result, list):
    print('[' + ', '.join(str(x) for x in result) + ']')
elif isinstance(result, bool):
    print('true' if result else 'false')
else:
    print(result)

--------------------
Γ£à PASS
   Testing java      : --- WRAPPED CODE ---
import java.util.*;

public class Main {
public int romanToInt(String s) {
    Map<Character, Integer> symbolValues = new HashMap<>();
    symbolValues.put('I', 1);
    symbolValues.put('V', 5);
    symbolValues.put('X', 10);
    symbolValues.put('L', 50);
    symbolValues.put('C', 100);
    symbolValues.put('D', 500);
    symbolValues.put('M', 1000);
    int result = symbolValues.get(s.charAt(0));
    for (int i = 1; i < s.length(); i++) {
        if (symbolValues.get(s.charAt(i)) > symbolValues.get(s.charAt(i - 1))) {
            result -= 2 * symbolValues.get(s.charAt(i - 1));
            result += symbolValues.get(s.charAt(i));
        } else {
            result += symbolValues.get(s.charAt(i));
        }
    }
    return result;
}
    public static void main(String[] args) {
    }
}
--------------------
--- WRAPPED CODE ---
import java.util.*;

public class Main {
public int romanToInt(String s) {
    Map<Character, Integer> symbolValues = new HashMap<>();
    symbolValues.put('I', 1);
    symbolValues.put('V', 5);
    symbolValues.put('X', 10);
    symbolValues.put('L', 50);
    symbolValues.put('C', 100);
    symbolValues.put('D', 500);
    symbolValues.put('M', 1000);
    int result = symbolValues.get(s.charAt(0));
    for (int i = 1; i < s.length(); i++) {
        if (symbolValues.get(s.charAt(i)) > symbolValues.get(s.charAt(i - 1))) {
            result -= 2 * symbolValues.get(s.charAt(i - 1));
            result += symbolValues.get(s.charAt(i));
        } else {
            result += symbolValues.get(s.charAt(i));
        }
    }
    return result;
}
    public static void main(String[] args) {
    }
}
--------------------
--- WRAPPED CODE ---
import java.util.*;

public class Main {
public int romanToInt(String s) {
    Map<Character, Integer> symbolValues = new HashMap<>();
    symbolValues.put('I', 1);
    symbolValues.put('V', 5);
    symbolValues.put('X', 10);
    symbolValues.put('L', 50);
    symbolValues.put('C', 100);
    symbolValues.put('D', 500);
    symbolValues.put('M', 1000);
    int result = symbolValues.get(s.charAt(0));
    for (int i = 1; i < s.length(); i++) {
        if (symbolValues.get(s.charAt(i)) > symbolValues.get(s.charAt(i - 1))) {
            result -= 2 * symbolValues.get(s.charAt(i - 1));
            result += symbolValues.get(s.charAt(i));
        } else {
            result += symbolValues.get(s.charAt(i));
        }
    }
    return result;
}
    public static void main(String[] args) {
    }
}
--------------------
Γ¥î FAIL
      FULL RESULT: {"input":"\"III\"","expected":"3","actual":"","passed":false,"isHidden":false}
      FULL RESULT: {"input":"\"LVIII\"","expected":"58","actual":"","passed":false,"isHidden":false}
      FULL RESULT: {"input":"\"MCMXCIV\"","expected":"1994","actual":"","passed":false,"isHidden":false}
   Testing javascript: --- WRAPPED CODE ---
function romanToInt(s) {
    const symbolValues = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    };
    let result = symbolValues[s[0]];
    for (let i = 1; i < s.length; i++) {
        if (symbolValues[s[i]] > symbolValues[s[i - 1]]) {
            result -= 2 * symbolValues[s[i - 1]];
            result += symbolValues[s[i]];
        } else {
            result += symbolValues[s[i]];
        }
    }
    return result;
}

const s = "III";
const result = romanToInt(s);
if (Array.isArray(result)) {
    console.log('[' + result.join(', ') + ']');
} else if (typeof result === 'boolean') {
    console.log(result ? 'true' : 'false');
} else {
    console.log(result);
}
--------------------
--- WRAPPED CODE ---
function romanToInt(s) {
    const symbolValues = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    };
    let result = symbolValues[s[0]];
    for (let i = 1; i < s.length; i++) {
        if (symbolValues[s[i]] > symbolValues[s[i - 1]]) {
            result -= 2 * symbolValues[s[i - 1]];
            result += symbolValues[s[i]];
        } else {
            result += symbolValues[s[i]];
        }
    }
    return result;
}

const s = "LVIII";
const result = romanToInt(s);
if (Array.isArray(result)) {
    console.log('[' + result.join(', ') + ']');
} else if (typeof result === 'boolean') {
    console.log(result ? 'true' : 'false');
} else {
    console.log(result);
}
--------------------
--- WRAPPED CODE ---
function romanToInt(s) {
    const symbolValues = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    };
    let result = symbolValues[s[0]];
    for (let i = 1; i < s.length; i++) {
        if (symbolValues[s[i]] > symbolValues[s[i - 1]]) {
            result -= 2 * symbolValues[s[i - 1]];
            result += symbolValues[s[i]];
        } else {
            result += symbolValues[s[i]];
        }
    }
    return result;
}

const s = "MCMXCIV";
const result = romanToInt(s);
if (Array.isArray(result)) {
    console.log('[' + result.join(', ') + ']');
} else if (typeof result === 'boolean') {
    console.log(result ? 'true' : 'false');
} else {
    console.log(result);
}
--------------------
Γ£à PASS

============================================================
SUMMARY: 3 passed, 2 failed
